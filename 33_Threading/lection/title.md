# Потоки, Мультипроцесорність

Згідно [Wikipedia](https://uk.wikipedia.org/wiki/%D0%9F%D0%BE%D1%82%D1%96%D0%BA_(%D1%96%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)),
> Потік (англ. thread) або повніше потік виконання (англ. thread of execution), часто застосовуються назви нитка, нитка виконання та англіцизм тред — в інформатиці так називається спосіб програми розділити себе на дві чи більше паралельні задачі. Реалізація потоків та процесів відрізняються в різних операційних системах, але загалом потік міститься всередині процесу і різні потоки одного процесу спільно розподіляють деякі ресурси, у той час як різні процеси ресурси не розподіляють.

![threads](img/threads.png)

**Нитка** є «найлегшим» об'єктом для планувальника ядра. Щонайменше одна нитка існує всередині кожного процесу. Якщо в процесі співіснують багато ниток, вони розподіляють одну пам'ять і файлові ресурси. Нитки не мають своїх власних ресурсів, за винятком стеку, копії регістрів включно з лічильником задач.

**Процес** є «найважчим» об'єктом для планувальника ядра операційної системи. Власні ресурси процесу розміщені операційною системою. Ресурси включають пам'ять, відкриті файли та пристрої, сокети та вікна. Процеси не розділяють з кимось адресний простір чи залучені файли.

Також слід визначитись із такими темінами як **синхронність** та **асинхронність**.
У **синхронних** операціях задачі виконуються послідовно, одна за одною.
В **асинхронних**  - задачі можуть запускатись та завершуватись незалежно одна від одної.
Асинхронні задачі не не блокують операції і зазвичай виконуються у фоновому режимі.

У Python для роботи з нитками(тредами) використовується бібліотека "threading".
Це стандартна бібліотека і не потребує встановлення.
Синтаксис надзвичайно простий:

```python
class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)
```

Тобто, найпростіший тред можна створити командою:

```python
my_thread = threading.Thread(target=foo, args=(n,))
```

У цій команді ```foo``` - це функція, яку виконуватиме тред, ```args``` - це аргумети, які передадуться функції.

**Зверність увагу:** вказується лише ім'я функції, без дужок. В якості аргументів має передаватись лише ітерабельний об'єкт (список, кортеж).

Тому для фунції

```python
def my_exponentiation(number):
    rezult = number ** 2
    print(rezult)
```

створення потоку вигладатиме наступим чином:

```python
number = 4
my_thread = threading.Thread(target=my_exponentiation, args=(number,))
```

Описаним вище способом ми створили екземпляр класу ```Thread```.
Тепер наш потік потрідно запустити для виконання. Це здійснюється за допомогою методу ```start()```.
У нашому прикладі це виглядатиме як ```my_thread.start()```.

Зазначеного коду достатньо, щоб створити та запустити потік (якщо не забути про ```inport threading```.)

Але радіти такій простоті рано, так як найбльша складність у роботі з потоками полягає у відстежуванні послідовності їх роботи.
Слід постійно пам'ятати, що створені нами треди, це такі самі потоки, як і основний потік програми і кожен окремий тред може мати свій час виконання.
це добре видно з наступного прикладу:

```python
# threading1
import threading
import time


def worker(number):
    thread_name = threading.current_thread().name
    for i in range(1000):
        number = i
        time.sleep(0.001)
    print(f"I am Worker {thread_name}, my number is {number}\n")


number = 0
t1 = threading.Thread(target=worker, name='t1', args=(number,))
t2 = threading.Thread(target=worker, name='t2', args=(number,))

t1.start()
t2.start()
# t1.join()
# t2.join()
print('Main thread is finished', '\n')

```

Результат має бути очевидним: після старту двох тредів, основному потоку залишається лише виконати отсанній ```print``` незалежно від результатів та часу роботи запущених тредів.

Тому і отримаємо:

```bash
Main thread is finished

I am Worker t2, my number is 999

I am Worker t1, my number is 999
```

Зверніть увагу, що тред №2 закінчив роботу раніше, ніж тред №1, хоча запущений був пізніше.
Цікаво також, що так трапляється не завжди. Інколи №1 фінішує першим, але через особливості коду, користувацькі потоки ніколи не обженуть основний потік.
